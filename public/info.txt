tar -czvf aara-ai-agent_2.tar.gz .



+-------------------+
|   User Interface  |
| (Chatbot Frontend)|
+-------------------+
          |
          v
+-------------------+
|   chatbot.js      |
| (Handles user     |
|  input and calls  |
|  appropriate APIs)|
+-------------------+
          |
          v
+-------------------+
|   playbook.js     |
| (Frontend logic   |
|  for executing    |
|  playbooks via API|
+-------------------+
          |
          v
+-------------------+
|   server.js       |
| (Backend server   |
|  handling API     |
|  requests and     |
|  executing Ansible|
|  playbooks)       |
+-------------------+
          |
          v
+-------------------+
|   Ansible         |
| (Executes         |
|  playbooks like   |
|  getosdetails.yml)|
+-------------------+
          |
          v
+-------------------+
|   Output          |
| (Playbook results |
|  returned to the  |
|  chatbot and      |
|  displayed to the |
|  user)            |
+-------------------+


Explanation of Components
User Interface (Chatbot Frontend):

The user interacts with the chatbot by typing commands like "run getosdetails playbook".
The chatbot sends the command to chatbot.js.
chatbot.js:

Handles user input and determines the appropriate action.
Calls functions like executegetosdetailsPlaybook from playbook.js.
playbook.js:

Contains logic for sending API requests to the backend (server.js).
Sends the playbook name and inventory file to the /run-playbook endpoint.
server.js:

Backend server that processes API requests.
Resolves the playbook and inventory paths and executes the playbook using ansible-playbook.
Ansible:

Executes the specified playbook (e.g., getosdetails.yml) using the inventory file.
Produces output, such as system details or task results.
Output:

The playbook output is sent back to the frontend via the API.
The chatbot displays the results to the user.



Next Steps
Based on your info.txt file:

Add More Ansible Playbooks:

Create additional playbooks for different tasks and integrate them into the chatbot.
Test API:

Use tools like curl or Postman to test the /run-playbook endpoint.
Add Variations:

Add more commands and variations to the chatbot's predefined answers.
Integrate LLM API:

Use a language model API (e.g., OpenAI GPT) for advanced chatbot responses.
User Authentication:

Implement username/password login functionality.
Dockerize the Application:

Create a Docker image for the application, push it to a server, and test it.


-------------------------------------------------------------------------



Below is the detailed documentation for your project in Markdown format. You can copy this into a Word document or any other format as needed.

UCD AI Agent Project Documentation
1. Project Overview
Purpose
The UCD AI Agent project is a chatbot-based automation tool designed to execute various system-level scripts and commands. It provides an interactive interface for users to communicate with the bot and perform tasks such as running shell scripts, managing services, and executing Ansible playbooks.

Key Features
Execute shell scripts like hello.sh and ansible.sh.
Run Ansible playbooks for system automation.
Fetch OS details and restart services.
Interactive chatbot interface with predefined responses and spell correction.
Speech synthesis for bot responses.
2. Software Requirements
Installed Software
Node.js: Backend server for handling requests and executing scripts.
Ansible: For running playbooks and automating system tasks.
Web Browser: For accessing the chatbot interface.
Linux Shell: For executing shell scripts.
Dependencies
Frontend: HTML, CSS, JavaScript.
Backend: Node.js with Express.js.
Other Tools: Speech synthesis API for voice responses.
3. Project Logic
Core Functionalities
Chatbot Interface:

Accepts user input and matches it with predefined commands.
Provides responses based on predefined answers or executes specific functions.
Script Execution:

Executes shell scripts like hello.sh and ansible.sh via backend endpoints.
Displays the output or error messages in the chat interface.
Ansible Playbooks:

Executes playbooks for tasks like fetching OS details or restarting services.
Spell Correction:

Corrects minor spelling mistakes in user input to improve command recognition.
Speech Synthesis:

Converts bot responses into speech for better user interaction.
4. Design
Frontend
HTML/CSS: Provides the chatbot interface.
JavaScript: Handles user input, bot responses, and API calls.
Backend
Node.js: Processes user requests and executes scripts.
Endpoints:
/run-script: Executes shell scripts.
/run-script-installansible: Installs Ansible.
Data Flow
User sends a message via the chat interface.
The message is processed and matched with predefined commands.
If a script needs to be executed, a request is sent to the backend.
The backend executes the script and returns the output.
The output is displayed in the chat interface.
5. Execution Flow
Example: Executing hello.sh
User Input: The user types execute hello.sh in the chat.
Frontend:
The executeHelloScript() function is called.
A POST request is sent to the /run-script endpoint with the script name.
Backend:
The server executes hello.sh using a child process.
The output or error is returned as a JSON response.
Frontend:
The response is displayed in the chat interface.
6. Advantages
Simplifies system automation with a user-friendly chatbot interface.
Reduces manual effort by automating repetitive tasks.
Provides real-time feedback for executed commands.
Supports spell correction for better user experience.
7. Disadvantages
Limited to predefined commands and scripts.
Requires backend setup and proper script permissions.
Dependent on the availability of required software (e.g., Ansible).
8. How to Use
Setup
Clone the repository:
Install dependencies:
Start the server:
Open the chatbot interface in a web browser.
Executing Commands
Type commands like execute hello.sh or install ansible in the chat input box.
The bot will process the command and display the output.
9. How to Execute
Example: Running hello.sh
Ensure the script hello.sh is present in the project directory.
Type execute hello.sh in the chat.
The bot will execute the script and display the output.
10. Problems Solved
Automates repetitive system tasks.
Provides a centralized interface for managing scripts and playbooks.
Reduces the need for manual command-line operations.
11. Future Scope
Add support for more scripts and playbooks.
Implement user authentication for secure access.
Enhance the chatbot with AI-based natural language processing.
Add logging and monitoring for executed commands.
Support multi-platform compatibility (Windows, macOS).


Setting Up the HTML Document
The chatbot.html file is already structured to work as the frontend for your chatbot. Ensure it is placed in the correct directory of your project:

Filepath: chatbot.html
Steps to Set Up
Verify File Placement:

Ensure the chatbot.html file is in the public folder of your project.
Check Linked Resources:

Verify that the linked CSS file (styles/styles.css) and JavaScript file (scripts/chatbot.js) exist in the specified paths.
Ensure the images/agent.png file exists in the images folder.
Start the Server:

If your project uses a Node.js server, start it using:
This will serve the chatbot.html file as part of your application.
Access the Chatbot:

Open a web browser and navigate to the URL where your server is running (e.g., http://localhost:3000/chatbot.html).
2. Integrating the Chatbot Logic
The chatbot logic is implemented in the chatbot.js file. To ensure the chatbot can process commands like execute hello.sh, follow these steps:

Frontend Integration
Dynamic Message Handling:

The chatbot.js script dynamically appends messages to the chat box (<div id="chat-box">) based on user input.
Command Recognition:

The sendMessage() function in chatbot.js processes user input and matches it with predefined commands.
For example, when the user types execute hello.sh, the executeHelloScript(addMessage) function is called.
Predefined Commands:

The list of commands in the <ul class="intro-list"> (e.g., execute hello.sh, install ansible) serves as a guide for users. These commands are matched in the JavaScript logic.
Backend Integration
API Endpoints:

The chatbot sends requests to backend endpoints (e.g., /run-script, /run-script-installansible) to execute scripts or perform tasks.
Script Execution:

For the execute hello.sh command:
The executeHelloScript(addMessage) function sends a POST request to the /run-script endpoint with the script name (hello.sh).
The backend executes the script and returns the output as a JSON response.
Server Setup:

Ensure your Node.js server has the necessary routes to handle these requests. For example:
3. Testing the Chatbot
Start the Server:

Run your Node.js server and ensure there are no errors.
Open the Chatbot Interface:

Navigate to the chatbot in your browser (e.g., http://localhost:3000/chatbot.html).
Test Commands:

Type execute hello.sh in the chat input box and verify that:
The bot responds with "Executing hello.sh script...".
The script output or error is displayed in the chat.
Debugging:

If the chatbot does not respond as expected, check:
The browser console for JavaScript errors.
The server logs for backend errors.
4. Future Enhancements
Dynamic Command List:
Fetch the list of available commands from the backend and dynamically populate the <ul class="intro-list">.
User Authentication:
Add a login system to restrict access to certain commands.
Enhanced Error Handling:
Display detailed error messages for failed script executions.
